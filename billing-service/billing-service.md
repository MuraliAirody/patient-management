# gRPC Billing Service – Explanation

This document explains the **Protocol Buffers (.proto)** definition and the corresponding **Java gRPC server implementation**.

---

### 1. Protocol Buffers Definition (`billing.proto`)

```protobuf
syntax = "proto3";
```
Specifies Protocol Buffers v3 syntax.

proto3 is the recommended and most widely used version.

Java Code Generation Options

```protobuf
option java_multiple_files = true;
option java_package = "billing";
```
java_multiple_files = true

- Generates one Java class per message/service instead of a single outer class.

- Improves readability and maintainability.

java_package = "billing"

- Generated Java classes will be placed under the billing package.

- Example generated classes:

BillingRequest

BillingResponse

BillingServiceGrpc

Service Definition
```protobuf
service BillingService {
  rpc CreateBillingAccount (BillingRequest) returns (BillingResponse);
}
```
- Defines a gRPC service named BillingService.

- Declares a unary RPC:

Input: BillingRequest

Output: BillingResponse

- Conceptually similar to a REST POST /billing-account, but RPC-based, not REST.

Request Message
```protobuf
message BillingRequest {
  string patientId = 1;
  string name = 2;
  string email = 3;
}
```

- Defines the request payload.

- Fields:

patientId: Unique patient identifier

name: Patient name

email: Patient email address

Field numbers (1, 2, 3) are used internally by Protobuf for serialization.

Response Message
```protobuf
message BillingResponse {
  string accountId = 1;
  string status = 2;
}
```
- Defines the response payload.

- Fields:

accountId: Generated billing account ID

status: Account status (e.g., ACTIVE, INACTIVE)

### 2. Java gRPC Server Implementation
```java
package com.pm.billing_service.grpc;
```
- Java package for the gRPC service implementation.

- Independent of the Protobuf **java_package**.

Imports
```java
import billing.BillingRequest;
import billing.BillingResponse;
import billing.BillingServiceGrpc;
import io.grpc.stub.StreamObserver;
import net.devh.boot.grpc.server.service.GrpcService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
```
- BillingRequest, BillingResponse

Generated from the .proto file.

- BillingServiceGrpc

Generated abstract base class for server-side implementation.

- StreamObserver

Used by gRPC to send responses asynchronously.

- @GrpcService

Provided by grpc-spring-boot-starter to register the service with Spring Boot.

Service Declaration
```java
@GrpcService
public class BillingGrpcService
        extends BillingServiceGrpc.BillingServiceImplBase {

```
- @GrpcService

Marks this class as a gRPC server component.

- BillingServiceImplBase

Abstract class generated by gRPC.

Requires overriding RPC methods defined in .proto.

Logger
```java
private static final Logger log =
        LoggerFactory.getLogger(BillingGrpcService.class);

```
- Used for request tracing and debugging.

RPC Method Implementation
```java

@Override
public void createBillingAccount(
        BillingRequest request,
        StreamObserver<BillingResponse> responseObserver) {
```
- Implements the CreateBillingAccount RPC.

- Parameters:

BillingRequest request → Client request

StreamObserver<BillingResponse> → Used to send the response

Request Logging
```java
log.info("createBillingAccount request received {}",
         request.toString());
```
- Logs incoming request details.

- Useful for debugging and audit purposes.

- Business Logic Placeholder
// Business logic - e.g save to database, perform calculations etc
- This is where:

Database persistence

Validation

Billing calculations

External service calls
would be implemented.

Building the Response
```java
BillingResponse response = BillingResponse.newBuilder()
        .setAccountId("12345")
        .setStatus("ACTIVE")
        .build();
```
- Uses Builder pattern (standard in Protobuf-generated classes).

- Creates an immutable BillingResponse.

Sending the Response
```java
responseObserver.onNext(response);
responseObserver.onCompleted();
```
- onNext(response)

Sends the response to the client.

- onCompleted()

Marks the RPC call as completed.

Required for unary RPCs.

### 3. End-to-End Flow
- Client calls CreateBillingAccount

- gRPC framework deserializes Protobuf request

- createBillingAccount() is invoked

- Business logic executes

- BillingResponse is built

- Response is sent back over HTTP/2

- Client receives the response

--- 
## Billing Service: Docker Image & Container Creation

This section explains how the Billing Service was packaged into a Docker image and then run as a Docker container using terminal commands.

### 1. Prerequisites

- Docker installed and running

- Dockerfile present in the billing-service project directory

- Docker internal network already created

- docker network create internal

### 2. Building the Billing Service Docker Image

- The Billing Service Docker image was created using the Dockerfile located in the billing service project directory.

Navigate to project directory
```shell
cd billing-service
```

Build the image
```shell
docker build -t patient-billing:latest .
```
Explanation

| Part                        | Description                        |
| --------------------------- | ---------------------------------- |
| `docker build`              | Builds a Docker image              |
| `-t patient-billing:latest` | Image name and tag                 |
| `.`                         | Current directory as build context |

- **Result:**

- A Docker image named patient-billing:latest is created

- The image contains the compiled Spring Boot application

- No container is started at this stage

Verify:

```shell
docker images
```
### 3. Creating and Running the Billing Service Container

Once the image was built, a container was created and started using the following command:

```shell
docker run \
--name billing-service \
--network internal \
-p 4001:4001 \
-p 9001:9001 \
-d patient-billing:latest
```

Explanation

| Option                   | Description                         |
| ------------------------ | ----------------------------------- |
| `--name billing-service` | Container name                      |
| `--network internal`     | Connects to internal Docker network |
| `-p 4001:4001`           | Exposes Billing Service API         |
| `-p 9001:9001`           | Exposes Actuator / Management port  |
| `-d`                     | Runs container in background        |
| `patient-billing:latest` | Image used to create container      |

### 4. Environment Configuration (Database Connectivity)

Environment variables for database connectivity were injected at container runtime, not during image build.

Using .env file (recommended)

.env file placed outside the application source code:

```properties

SPRING_DATASOURCE_URL=jdbc:postgresql://patient-service-db:5432/db
SPRING_DATASOURCE_USERNAME=admin_user
SPRING_DATASOURCE_PASSWORD=password

```

- Container recreated with env variables
- docker stop billing-service
- docker rm billing-service

```shell
docker run \
--name billing-service \
--network internal \
-p 4001:4001 \
-p 9001:9001 \
--env-file .env \
-d patient-billing:latest
```

### 5. How Billing Service Connects to Database

- Both Billing Service and PostgreSQL containers are attached to the same internal Docker network

- Docker provides built-in DNS resolution

- Billing Service connects using the container name patient-service-db

- jdbc:postgresql://patient-service-db:5432/db

**Important Note**

- Port 5432 is the container port

- Host-mapped ports (e.g., 6000) are not used for container-to-container communication

### 6. Verification
Check running container
```shell
   docker ps
```
- View logs
- docker logs billing-service

Verify environment variables
```shell
docker exec billing-service printenv | grep SPRING
```